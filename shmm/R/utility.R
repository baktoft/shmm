# Spatial hidden Markov model (SHMM)
#    Copyright (C) 2015-2016  Martin Waever Pedersen, mawp@dtu.dk or wpsgodd@gmail.com
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#' An S4 class to represent output from a shmm fit.
#' @name shmmcls
#' @aliases shmmcls-class
#' @exportClass shmmcls
setClass("shmmcls")

#' @name ind2sub
#' @title Linear index to subscripts
#' @param ind Linear index
#' @param nrows Number of rows
#' @return Subscripts
#' @export
ind2sub <- function(ind, nrows){
    return(list(r = ((ind-1) %% nrows) + 1,
                c = floor((ind-1) / nrows) + 1))
}


#' @name find.land
#' @title Function to remove lakes etc.
#' @param nas Matrix containing NAs at land cells
#' @param do.plot Plot progress
#' @return Matrix containing TRUE at land and FALSE at connected water.
#' @export
find.land <- function(nas, do.plot=FALSE){
    nrows <- nrow(nas)
    ncols <- ncol(nas)
    land1 <- matrix(0, nrow=nrows, ncol=ncols)
    land2 <- matrix(0, nrow=nrows, ncol=ncols)
    rs <- round(nrows/2)
    cs <- round(ncols/2)
    land2[rs, cs] <- 1
    I <- c(1, 0, -1, 0)
    J <- c(0, 1, 0, -1)
    ninds <- 1
    while (ninds > 0){
        inds <- which(land1 != land2)
        sub <- ind2sub(inds, nrows)
        ninds <- length(inds)
        land1 <- land2 # Store old
        if (ninds > 0){
            for (i in 1:ninds){
                ii <- sub$r[i]
                jj <- sub$c[i]
                for (j in 1:4){
                    iii <- max(min(ii + I[j], nrows), 1)
                    jjj <- max(min(jj + J[j], ncols), 1)
                    if (!nas[iii, jjj] & land2[iii, jjj]!=1){
                        land2[iii, jjj] <- 1
                    }
                }
            }
        }
        if (do.plot){
            par(mfrow=c(2, 2))
            image(land1)
            image(land2)
            image(land1!=land2)
        }
    }
    return(land2 == 0)
}



#' @name time.fac
#' @title Number of seconds in a day
#' @return Number of seconds in a day
#' @export
time.fac <- function(){
    return(24 * 60 * 60)
}

#' @name set.default
#' @title Set default parameter value
#' @param inpin Input list
#' @param key Key of list
#' @param val Value
#' @return Modified inpin
#' @export
set.default <- function(inpin, key, val){
    if (!key %in% names(inpin)){
        inpin[[key]] <- val
    }
    return(inpin)
}


#' @name test.shmm
#' @title Example of a shmm analysis.
#' @details Loads a data set, fits the model, plots the results.
#' @param nobs Number of observations to simulate
#' @return A result report as given by fit.shmm().
#' @examples
#' rep <- test.shmm()
#' @export
test.shmm <- function(nobs=40){

    inp <- list()
    inp$datatype <- 'xy'

    # Parameters
    inp$ini$logsdx <- log(6)
    inp$ini$logsdy <- log(5)
    inp$osd <- 1 # Observation error sd
    inp$dt <- 1

    inp$grid$dx <- 1
    inp$grid$dy <- 1

    # Simulate
    inp <- sim.shmm(inp, nobs=nobs)

    # Make grid
    # X
    xmin <- min(inp$true$X) - 0.1*diff(range(inp$true$X))
    xmax <- max(inp$true$X) + 0.1*diff(range(inp$true$X))
    inp$grid$xx <- seq(xmin, xmax, by=inp$grid$dx)
    inp$grid$nx <- length(inp$grid$xx)
    # Y
    ymin <- min(inp$true$Y) - 0.1*diff(range(inp$true$Y))
    ymax <- max(inp$true$Y) + 0.1*diff(range(inp$true$Y))
    inp$grid$yy <- seq(ymin, ymax, by=inp$grid$dy)
    inp$grid$ny <- length(inp$grid$yy)
    # Land
    indsy <- which(inp$grid$yy > 6 & inp$grid$yy < 8)
    indsx <- which(inp$grid$xx > 1 & inp$grid$xx < 4)
    dummy <- matrix(0, inp$grid$nx, inp$grid$ny)
    #dummy[indsx, indsy] <- 1
    inp$land <- which(dummy==1)
    cat('nx: ', inp$grid$nx, ' ny: ', inp$grid$ny, ' no states: ', inp$grid$nx*inp$grid$ny, '\n')

    # Calculate data likelihood
    inp <- calc.data.likelihood(inp)
    
    # Fit shmm
    rep <- fit.shmm(inp)

    return(rep)
}


#' @name get.par
#' @title Extract parameters from a result report as generated by fit.shmm.
#' @details Helper function for extracting the value and uncertainty of a specific model parameter or derived quantity.
#' @param parname Character string containing the name of the variable of interest.
#' @param rep A result report as generated by running fit.shmm.
#' @param exp Take exp of the variable? TRUE/FALSE.
#' @return A matrix with four columns containing respectively: 1) the lower 95% confidence limit; 2) the parameter estimate; 3) the upper 95% confidence limit; 4) the parameter standard deviation in the domain it was estimated (log or non-log).
#' @export
#' @examples
#' logD <- get.par('logD', rep, exp=TRUE)
get.par <- function(parname, rep=rep, exp=FALSE){
}


#' @name invlogit
#' @title Inverse logit transform.
#' @param a Value to take inverse logit of.
#' @return Inverse logit.
invlogit <- function(a) 1/(1+exp(-a))


#' @name invlogp1
#' @title Inverse log "plus one" transform
#' @details If a = log(b-1), then the inverse transform is b = 1 + exp(a). Useful for values with lower bound at 1.
#' @param a Value to take inverse logp1 of.
#' @return Inverse logp1.
invlogp1 <- function(a) 1 + exp(a)


#' @name format.distr
#' @title Format distribution from flattened time x vector (2D) to time x matrix (3D).
#' @param vecdistr Distribution to be formatted
#' @param rep Result of running fit.shmm.
#' @return The requested distribution as an 3D-array.
#' @export
format.distr <- function(vecdistr, rep){
    nt <- dim(vecdistr)[1]
    distr <- array(0, dim=c(nt, rep$inp$grid$nx, rep$inp$grid$ny))
    landinds <- which(rep$inp$land)
    for (i in 1:nt){
        if (length(landinds) > 0){
            temp <- matrix(0, rep$inp$grid$nx, rep$inp$grid$ny)
            temp[-landinds] <- vecdistr[i, ]
            distr[i, , ] <- temp
        } else {
            distr[i, , ] <- matrix(vecdistr[i, ], rep$inp$grid$nx, rep$inp$grid$ny)
        }
    }
    return(distr)
}


#' @name get.mean.track
#' @title Calculate an estimated track from the mean of the smoothed distribution.
#' @param rep Result of running fit.shmm.
#' @return A list containing 
#' @export
get.mean.track <- function(rep){
    if (rep$inp$do.smoo == 1){
        distr <- rep$report$smoo
    } else {
        distr <- rep$report$phi
    }
    nt <- dim(distr)[1]
    Xmean <- numeric(nt)
    Ymean <- numeric(nt)
    for (t in 1:nt){
        Xmean[t] <- sum(apply(distr[t, , ], 1, sum) * rep$inp$grid$xx)
        Ymean[t] <- sum(apply(distr[t, , ], 2, sum) * rep$inp$grid$yy)
    }
    rep$tracks$Xmean <- Xmean
    rep$tracks$Ymean <- Ymean
    return(rep)
}


sd2D <- function(sd, dx){
    return(0.5 * (sd/dx)^2)
}

D2sd <- function(D, dx){
    return(sqrt(2*D) * dx)
}
