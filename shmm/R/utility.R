# Spatial hidden Markov model (SHMM)
#    Copyright (C) 2015-2016  Martin Waever Pedersen, mawp@dtu.dk or wpsgodd@gmail.com
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#' An S4 class to represent output from a shmm fit.
#' @name shmmcls
#' @aliases shmmcls-class
#' @exportClass shmmcls
setClass("shmmcls")


#' @name set.default
#' @title Set default parameter value
#' @param inpin Input list
#' @param key Key of list
#' @param val Value
#' @return Modified inpin
#' @export
set.default <- function(inpin, key, val){
    if (!key %in% names(inpin)){
        inpin[[key]] <- val
    }
    return(inpin)
}


#' @name test.shmm
#' @title Example of a shmm analysis.
#' @details Loads a data set, fits the model, plots the results.
#' @param nobs Number of observations to simulate
#' @return A result report as given by fit.shmm().
#' @examples
#' rep <- test.shmm()
#' @export
test.shmm <- function(nobs=40){

    inp <- list()
    inp$datatype <- 'xy'

    # Parameters
    inp$ini$logsdx <- log(6)
    inp$ini$logsdy <- log(5)
    inp$osd <- 1 # Observation error sd
    inp$dt <- 1

    inp$grid$dx <- 1
    inp$grid$dy <- 1

    # Simulate
    inp <- sim.shmm(inp, nobs=nobs)

    # Make grid
    # X
    xmin <- min(inp$true$X) - 0.1*diff(range(inp$true$X))
    xmax <- max(inp$true$X) + 0.1*diff(range(inp$true$X))
    inp$grid$xx <- seq(xmin, xmax, by=inp$grid$dx)
    inp$grid$nx <- length(inp$grid$xx)
    # Y
    ymin <- min(inp$true$Y) - 0.1*diff(range(inp$true$Y))
    ymax <- max(inp$true$Y) + 0.1*diff(range(inp$true$Y))
    inp$grid$yy <- seq(ymin, ymax, by=inp$grid$dy)
    inp$grid$ny <- length(inp$grid$yy)
    # Land
    indsy <- which(inp$grid$yy > 6 & inp$grid$yy < 8)
    indsx <- which(inp$grid$xx > 1 & inp$grid$xx < 4)
    dummy <- matrix(0, inp$grid$nx, inp$grid$ny)
    #dummy[indsx, indsy] <- 1
    inp$land <- which(dummy==1)
    cat('nx: ', inp$grid$nx, ' ny: ', inp$grid$ny, ' no states: ', inp$grid$nx*inp$grid$ny, '\n')

    # Calculate data likelihood
    inp <- calc.data.likelihood(inp)
    
    # Fit shmm
    rep <- fit.shmm(inp)

    return(rep)
}


#' @name get.par
#' @title Extract parameters from a result report as generated by fit.shmm.
#' @details Helper function for extracting the value and uncertainty of a specific model parameter or derived quantity.
#' @param parname Character string containing the name of the variable of interest.
#' @param rep A result report as generated by running fit.shmm.
#' @param exp Take exp of the variable? TRUE/FALSE.
#' @return A matrix with four columns containing respectively: 1) the lower 95% confidence limit; 2) the parameter estimate; 3) the upper 95% confidence limit; 4) the parameter standard deviation in the domain it was estimated (log or non-log).
#' @export
#' @examples
#' logD <- get.par('logD', rep, exp=TRUE)
get.par <- function(parname, rep=rep, exp=FALSE){
}


#' @name invlogit
#' @title Inverse logit transform.
#' @param a Value to take inverse logit of.
#' @return Inverse logit.
invlogit <- function(a) 1/(1+exp(-a))


#' @name invlogp1
#' @title Inverse log "plus one" transform
#' @details If a = log(b-1), then the inverse transform is b = 1 + exp(a). Useful for values with lower bound at 1.
#' @param a Value to take inverse logp1 of.
#' @return Inverse logp1.
invlogp1 <- function(a) 1 + exp(a)


#' @name get.distr
#' @title Extract distribution from rep
#' @param name Name of the distribution to plot. Either 'phi', 'pred' or 'smoo'.
#' @param rep Result of running fit.shmm.
#' @return The requested distribution as an 3D-array.
#' @export
get.distr <- function(name, rep){
    if (name %in% names(rep$obj$report())){
        vecdistr <- rep$obj$report()[[name]]
        distr <- array(0, dim=c(rep$inp$ns, rep$inp$grid$nx, rep$inp$grid$ny))
        for (i in 1:rep$inp$ns){
            distr[i, , ] <- matrix(vecdistr[i, ], rep$inp$grid$nx, rep$inp$grid$ny)
        }
        return(distr)
    } else {
        stop(name, 'not in names(rep$obj$report()!')
    }
}

#' @name get.mean.track
#' @title Calculate an estimated track from the mean of the smoothed distribution.
#' @param rep Result of running fit.shmm.
#' @return A list containing 
#' @export
get.mean.track <- function(rep){
    if (rep$inp$dosmoo == 1){
        smoo <- get.distr('smoo', rep)
        Xmean <- numeric(rep$inp$ns)
        Ymean <- numeric(rep$inp$ns)
        for (t in 1:rep$inp$ns){
            Xmean[t] <- sum(apply(smoo[t, , ], 1, sum) * rep$inp$grid$xx)
            Ymean[t] <- sum(apply(smoo[t, , ], 2, sum) * rep$inp$grid$yy)
        }
        rep$tracks$Xmean <- Xmean
        rep$tracks$Ymean <- Ymean
    } else {
        warning('Could not calculate mean track as dosmoo != 1')
    }
    return(rep)
}


sd2D <- function(sd, dx){
    return(0.5 * (sd/dx)^2)
}

D2sd <- function(D, dx){
    return(sqrt(2*D) * dx)
}
