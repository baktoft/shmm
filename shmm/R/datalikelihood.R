# Spatial hidden Markov model (SHMM)
#    Copyright (C) 2015-2016  Martin Waever Pedersen, mawp@dtu.dk or wpsgodd@gmail.com
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


#' @name calc.data.likelihood
#' @title Calculate data likelihood
#' @details Calculate data likelihood
#' @param parname Character string containing the name of the variable of interest.
#' @param rep A result report as generated by running fit.shmm.
#' @param exp Take exp of the variable? TRUE/FALSE.
#' @return Input list containing combined data likelihood of all data sources. Format is a matrix where nrow is equal to number of time steps, and ncol is equal to the total number of grid cells.
#' @export
#' @examples
#' inp <- calc.data.likelihood(inp)
calc.data.likelihood <- function(inp){
    fac <- time.fac()
    inp <- check.inp(inp)

    if ('xy' %in% inp$datatypes & !'xy' %in% names(inp$datlik)){
        nobs <- length(inp$obs$X)
        inp$datlik$xy <- array(0, dim=c(nobs, inp$grid$nx, inp$grid$ny))
        for (i in 1:nobs){
            inp$datlik$xy[i, , ] <- outer(dnorm(inp$grid$xx, inp$obs$X[i], inp$osd),
                                          dnorm(inp$grid$yy, inp$obs$Y[i], inp$osd))
        }
    }

    if ('sst' %in% inp$datatypes & !'sst' %in% names(inp$datlik)){
        # Add code to calculate SST datlik
    }

    if ('lon' %in% inp$datatypes & !'lon' %in% names(inp$datlik)){
        # Add code to calculate Lon datlik
    }

    # Combined data likelihood for all data types
    # NOT DONE
    nt <- length(inp$datliktime)
    inp$datlik$all <- matrix(1, nt, inp$grid$n)
    for (nm in inp$datatypes){
        obstime <- as.numeric(inp$obstimeuse[[nm]]) / fac
        inds <- match(obstime, inp$datliktime)
        c <- 1 # Counter
        for (i in inds){
            distr <- inp$datlik[[nm]][c, , ]
            inp$datlik$all[i, ] <- inp$datlik$all[i, ] * as.vector(distr[!inp$land])
            c <- c+1
        }
    }
    
    return(inp)
}


#' @name get.datlik.sst
#' @title Get SST data likelihood
#' @details Get data likelihood based on SST (SeaSurfaceTemperatures)
#' @param grid Array of SST measurements. dim(grid)=c(nTime, nLon, nLat).
#' @param obs Vector of temperature values observed from tag. length(obs)=nTime.
#' @param sds Vector of standard deviations to be used for calculating datlik.sst. length(sds)=nTime.
#' @param times Vector of times. length(times)=nTime.
#' @return List containing datlik_sst: Array of daily likelihoods given the input data; times: vector of corresponding times
get.datlik.sst <- function(grid, obs, sds, times){
	datlik_sst <- dnorm(grid, obs, sds)
	dimnames(datlik_sst) <- NULL
	return(list(datlik_sst=datlik_sst, times=times))
}

#' @name get.datlik.sun
#' @title Get data likelihood based on sunrise and sunset.
#' @details Get data likelihood based on sunrise and sunset.
#' @param grid_lon Vector of longitudes to build grid from.
#' @param grid_lat Vector of lattitudes to build grid from.
#' @param dat_sun Dataframe obtained from get.dat.sun().
#' @param solarDep Numeric value with the angle of the sun below the horizon in degrees. 6 seems to be good based on know values at start.
#' @return List containing datlik_lon: Array of daily likelihoods given the input data; times: vector of corresponding times
get.datlik.sun <- function(grid_lon, grid_lat, dat_sun, solarDep=6){
	grid <- expand.grid(x=grid_lon, y=grid_lat)
	sp::coordinates(grid) <- c("x","y")
	SP <- sp::SpatialPoints(sp::coordinates(grid),proj4string=sp::CRS("+proj=longlat +datum=WGS84"))

	datlik_sun <- plyr::daply(dat_sun, 1, .progress="text",  function(k) {
		date <- k$date
		if(k$sr_rm == 0){
			dawn <- maptools::crepuscule(SP, date, solarDep=solarDep, direction="dawn")
			dawn_mat <- matrix(dawn, ncol=length(grid_lat), nrow=length(grid_lon))
			dawn_lik <- dnorm(dawn_mat, k$sr, sd=2e-2) #Maybe add a component from depth at sunrise
		} else {
			dawn_lik <- matrix(1, ncol=length(grid_lat), nrow=length(grid_lon))
		}
		if(k$ss_rm == 0){
			dusk <- maptools::crepuscule(SP, date, solarDep=solarDep, direction="dusk")
			dusk_mat <- matrix(dusk, ncol=length(grid_lat), nrow=length(grid_lon))
			dusk_lik <- dnorm(dusk_mat, k$ss, sd=2e-2) #Maybe add a component from depth at sunset
		} else {
			dusk_lik <- matrix(1, ncol=length(grid_lat), nrow=length(grid_lon))
		}
		if(k$sr_rm == 0 & k$ss_rm == 0){
			daylength_mat <- dusk_mat - dawn_mat
			daylength_lik <- dnorm(daylength_mat, k$ss - k$sr, sd=2e-2)
		} else {
			daylength_lik <- matrix(1, ncol=length(grid_lat), nrow=length(grid_lon))
		}
		return(dusk_lik * dawn_lik * daylength_lik)
	})
	dimnames(datlik_sun) <- NULL
	rms <- which(dat_sun$sr_rm == 1 & dat_sun$ss_rm == 1)
	datlik_sun <- datlik_sun[-rms,,]
	datlik_sun[is.na(datlik_sun)] <- 0 #TMB does not like NAs
	times <- dat_sun$date[-rms]
	return(list(datlik_sun = datlik_sun, times=times))
}

#' @name get.datlik.lon
#' @title Get data likelihood based on lon estimates.
#' @details Get data likelihood based on lon estimates.
#' @param grid_lon Vector of longitudes to build grid from.
#' @param grid_lat Vector of lattitudes to build grid from.
#' @param f_lon Vector of longitudes to estimate likelihood for.
#' @param sds Vector of standard deviations to be used for calculating likelihood.
#' @param times Vector of times. length(times)=nTime.
#' @return List containing datlik_lon: Array of daily likelihoods given the input data; times: vector of corresponding times
get.datlik.lon <- function(grid_lon, grid_lat, f_lon, sd, times){
	df <- data.frame(id=seq(1:length(f_lon)), f_lon=f_lon, sd=sd)
	datlik_lon <- daply(df,1, function(k){
		f_lon_i <- as.numeric(k['f_lon'])
		sd_i <- as.numeric(k['sd'])
		outer(grid_lon, grid_lat, FUN=function(grid_lon,grid_lat) {dnorm(grid_lon, f_lon_i, sd_i)})
	})
	return(list(datlik_lon = datlik_lon, times=times))
}

