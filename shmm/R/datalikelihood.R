# Spatial hidden Markov model (SHMM)
#    Copyright (C) 2015-2016  Martin Waever Pedersen, mawp@dtu.dk or wpsgodd@gmail.com
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


#' @name calc.data.likelihood
#' @title Calculate data likelihood
#' @details Calculate data likelihood
#' @param parname Character string containing the name of the variable of interest.
#' @param rep A result report as generated by running fit.shmm.
#' @param exp Take exp of the variable? TRUE/FALSE.
#' @return Input list containing combined data likelihood of all data sources. Format is a matrix where nrow is equal to number of time steps, and ncol is equal to the total number of grid cells.
#' @export
#' @examples
#' inp <- calc.data.likelihood(inp)
calc.data.likelihood <- function(inp){
    fac <- time.fac()
    inp <- check.inp(inp)

    if ('xy' %in% inp$datatypes & !'xy' %in% names(inp$datlik)){
        nobs <- length(inp$obs$X)
        inp$datlik$xy <- array(0, dim=c(nobs, inp$grid$nx, inp$grid$ny))
        for (i in 1:nobs){
            inp$datlik$xy[i, , ] <- outer(dnorm(inp$grid$xx, inp$obs$X[i], inp$osd),
                                          dnorm(inp$grid$yy, inp$obs$Y[i], inp$osd))
        }
    }

    if ('sst' %in% inp$datatypes & !'sst' %in% names(inp$datlik)){
        # Add code to calculate SST datlik
    }

    if ('lon' %in% inp$datatypes & !'lon' %in% names(inp$datlik)){
        # Add code to calculate Lon datlik
    }

    # Combined data likelihood for all data types
    # NOT DONE
    nt <- length(inp$datliktime)
    inp$datlik$all <- matrix(1, nt, inp$grid$n)
    for (nm in inp$datatypes){
        obstime <- as.numeric(inp$obstimeuse[[nm]]) / fac
        inds <- match(obstime, inp$datliktime)
        c <- 1 # Counter
        for (i in inds){
            distr <- inp$datlik[[nm]][c, , ]
            inp$datlik$all[i, ] <- inp$datlik$all[i, ] * as.vector(distr[!inp$land])
            c <- c+1
        }
    }
    
    return(inp)
}


#' @name get.datlik.sst
#' @title Get SST data likelihood
#' @details Get data likelihood based on SST (SeaSurfaceTemperatures)
#' @param grid Array of SST measurements. dim(grid)=c(nTime, nLon, nLat).
#' @param obs Vector of temperature values observed from tag. length(obs)=nTime.
#' @param sds Vector of standard deviations to be used for calculating datlik.sst. length(sds)=nTime.
#' @param times Vector of times. length(times)=nTime.
#' @return List containing datlik_sst: Array of daily likelihoods given the input data; times: vector of corresponding times
get.datlik.sst <- function(grid, obs, sds, times){
	datlik_sst <- dnorm(grid, obs, sds)
	return(list(datlik_sst=datlik_sst, times=times))
}

#' @name get.datlik.lon
#' @title Get data likelihood based on lon estimates.
#' @details Get data likelihood based on lon estimates.
#' @param grid_lon Vector of longitudes to build grid from.
#' @param grid_lat Vector of lattitudes to build grid from.
#' @param f_lon Vector of longitudes to estimate likelihood for.
#' @param sds Vector of standard deviations to be used for calculating likelihood.
#' @param times Vector of times. length(times)=nTime.
#' @return List containing datlik_lon: Array of daily likelihoods given the input data; times: vector of corresponding times
get.datlik.lon <- function(grid_lon, grid_lat, f_lon, sd, times){
	df <- data.frame(id=seq(1:length(f_lon)), f_lon=f_lon, sd=sd)
	datlik_lon <- daply(df,1, function(k){
		f_lon_i <- as.numeric(k['f_lon'])
		sd_i <- as.numeric(k['sd'])
		outer(grid_lon, grid_lat, FUN=function(grid_lon,grid_lat) {dnorm(grid_lon, f_lon_i, sd_i)})
	})
	return(list(datlik_lon = datlik_lon, times=times))
}

